---
layout: single
title:  "GCC 8.1 (Nouveautés du langage C++)"
date:   2018-05-07 17:03:31 +0100
categories:
  - Posts
  - C++
---

{% include toc %}

## Introduction
La version 8.1 du compilateur GCC est sortie le 25 Avril 2018. Les nouveautés de
cette version pour les différents langages sont disponibles
[ici](https://gcc.gnu.org/gcc-8/changes.html). Dans ce post, nous allons voir
les nouveautés qui concernent le langage C++.

## Support expériemental de certaines fonctionalités du prochain standard C++2a

Le compilateur propose les options `-std=c++2a` ou `std=gnu++2a` pour utiliser
certaines fonctionalités du standard C++2a en cours de finalisation.

### C++2a (langage)

#### Initialisation par défaut des membres de type *bit*
Les membres de classes/structures de type *bit* peuvent avoir leur
initialisation par défaut. Même si l'otpion `-stc=c++2a` n'est pas utilisée,
le compilateur acceptera l'instruction avec un message d'avertissement.

```
default_init_bit_field.cpp:7:15: warning: default member initializers for bit-fields only available with -std=c++2a or -std=gnu++2a
     int x : 3 = 2;
```

#### Capture `[=, this]`
Cette fonctionalité mineure autorise l'utilisation de la syntaxe suivante
`[=, this]` qui était considérée comme une erreur. Elle est équivalente à la
syntaxe `[=]` mais son autorisation permet de faire la différence plus
clairement avec la syntaxe `[=, *this]`.

#### Les pointeurs vers des membres const par référence
Cette fonctionalité corrige un problème dans l'interprétation des pointeurs vers
membres qui sont `const &`.

Avant de voir le changement, commençons par utiliser un membre  *ref qualified*

```cpp
struct foo
{
    void f() &;
};
```

Cette déclaration interdit d'avoir un appel de ce type
```cpp
  foo{}.f();
```

Par contre on peut faire ceci:
```cpp
struct foo
{
    void f() const & {};
};

int main(int argc, char *argv[])
{
    foo{}.f();
}
```

Par contre, lors de l'utilisation de `.*` avec un objet temporaire (ou pour
être plus précis une *rvalue*), le langage interdisait d'avoir un pointeur
vers une fonction membre avec le *qualifier &*. Ceci donnait une incohérence
entre l'interprétation de deux instructions équivalentes.

```cpp
struct foo
{
    void f() const & {};
};

int main(int argc, char *argv[])
{
    foo{}.f();
    (foo{}.*(&foo::f))();
}
```

La compilation du programme ci-dessous donnait le résultat suivant:
```
error: pointer-to-member-function type 'void (foo::*)() const &' requires an lvalue
     (foo{}.*(&foo::f))();
```

La norme c++2a permet de remédier à cette incohérence, et les deux syntaxes sont
acceptées. A noter que l'utilisation de l'option `-std=c++2a` n'est pas
nécessaire avec *gcc* pour compiler le programme précédent.

#### Simplication des règles pour les boucles sur une plage (*range-based loop*)

#### Simplication des captures dans les lambdas

#### Clarification de la déduction des règles de déduction des arguments des templates

### C++2a (libstdc++)

## Amélioration de la gestion des erreurs de compilation

### Accès à un membre privé lorsqu'un accesseur est disponible

Cette fonctionalité permet si on accède à un membre privé d'afficher l'accesseur
correspondant. Un exemple montrant son Utilisation

```cpp
struct foo
{
public:
    int get_x() const { return x; }
private:
    int x;
};

int main(int, char*argv[]) {
    foo f;
    cout << f.x << endl;
}
```

```
gcc8_getter.cpp: In function 'int main(int, char**)':
gcc8_getter.cpp:15:15: error: 'int foo::x' is private within this context
     cout << f.x << endl;
               ^~
gcc8_getter.cpp:10:9: note: declared private here
     int x;
         ^~
gcc8_getter.cpp:15:15: note: field 'int foo::x' can be accessed via 'int foo::get_x() const'
     cout << f.x << endl;
               ^~
      get_x()
```


### Utilisation d'un macro utilisée avant sa définition

Cette aide à la compilation permet d'indiquer si la macro a été utilisée avant
sa définition.

```cpp
const int x = 3 * PI;

#define PI 3.14

int main(int, char*argv[]) {
}
```
### Cast

L'option `-Wold-style-cast` permet d'afficher un message d'aide pour indique
quand utiliser `static_cast`, 'const_cast' ou 'reinterpret_cast'

```cpp
struct base {};
struct foo : public base {};
int main(int, char *argv[]) {
  {
    base *b = new foo;
    foo *f = (foo *)b;
    delete b;
  }
  {
    const foo f1;
    foo &f2 = (foo &)f1;
  }
}
```

```
gcc8_cast.cpp: In function 'int main(int, char**)':
gcc8_cast.cpp:8:21: warning: use of old-style cast to 'struct foo*' [-Wold-style-cast]
     foo *f = (foo *)b;
                     ^
              --------
              static_cast<foo *> (b)
gcc8_cast.cpp:13:22: warning: use of old-style cast to 'struct foo&' [-Wold-style-cast]
     foo &f2 = (foo &)f1;
                      ^~
               ---------
               const_cast<foo &> (f1)
```

### Erreur dans un bloc `extern "C"`

### Arguments des templates non concordants

## LIBSTDC++
